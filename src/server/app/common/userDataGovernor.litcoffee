
# userDataGovernor module

This module is responsible for checking, adding, manipulating, modifying and other generalized operations on user data (that is all the documents that were generated by the user either on MOFS or on other sources).

### Initialization

    _       = require 'lodash'
    debug   = (require 'debug') 'memdive::common::userDataGovernor'
    frugal  = require 'frugal-couch'

    app = undefined

The module is integrated into CompoundJS application.

    module.exports.init = (compound) ->
        compound.on 'ready', (compoundApp) ->
            app = compoundApp

            app.common = app.common or {}
            app.common.userDataGovernor = exports
            app.emit 'userDataGovernorReady'

## Constants

    USER_DATA_VIEW_DOC = 'userData'
    VIEW = 'view'
    USER_TEXT_SEARCH_DOC = 'userText'
    INDEX = 'index'
    ARBITRARILY_OPTIMAL_ITERATION_LIMIT = 10000

## Private functions

## Public functions

### `updateUtcOffset`

`updateUtcOffset` updates `utcOffset` property on all documents associated with the user. This function will retrieve all the user documents in arbitrarily long iterations (100 for now), update their `utcOffset` property and bulk upload them back to the database.

`user`:     `User` model object representing the user whose documents we will be updating.
`callback`: function of `(error)` signature invoked with error or with no parameters if no error occurrs.

    updateUtcOffset = (user, callback) ->

        debug 'Updating the utcOffset on all documents for', user.id

        return frugal.iterateViewBulk app.couch, USER_DATA_VIEW_DOC, VIEW, {

We want **all** the user's docs so our start and end key are the beginning and the end of `user.id` space (see CouchDb documentation for explanation of `{}`)

                startkey:       [user.id],
                endkey:         [user.id, {}],
                limit:          ARBITRARILY_OPTIMAL_ITERATION_LIMIT,

We need to include the docs as after all that's what we are after. This requires turning of `reduce`.

                reduce:         false,
                include_docs:   true

            }, (error, viewRows, next) ->

                debug '\tIterating for', user.id, viewRows.length

                if error
                    debug 'Failed to iterate over the view:', error
                    return callback error

                if _.isEmpty(viewRows) or not next
                    debug 'Done updating utcOffset for', user.id
                    return callback()

Update all the docs in memory. Views return keys, values and docs (when `include_docs` is set to `true`). All we care about are the docs.

                docs = _.map viewRows, (row) ->
                    doc = row.doc
                    doc.utcOffset = user.utcOffset
                    return row.doc

                debug '\tUpdated docs for', user.id

Update all the docs in the database through dbs bulk facilities. We don't care about the result of this operation as we don't need the docs nor the new revision numbers.

                app.couch.bulk { docs: docs }, (error, result) ->

                    debug '\tBulk uploaded docs for', user.id

                    return callback error if error

                    # Onward to the next iteration.
                    next()

    exports.updateUtcOffset = updateUtcOffset

### `searchUserText`

`searchUserText` searches indexed user text with the given query parameters and starting with the given optional search bookmark. It will return results in bulks of 25 docs, up to 200 results total.

`user`:         `User` model object representing the user whose documents we will be searching.
`query`:        string with query conditions
`bookmark`:     optional string representing search bookmark
`callback`:     function of `(error, docs, bookmark)` signature invoked with error in case of failure, otherwise with `null`, array of docs and the bookmark for the next search request.

    searchUserText = (user, query, bookmark, callback) ->

        debug 'searching the text of all documents for', user.id

        if _.isFunction bookmark
            callback = bookmark
            bookmark = undefined

Create search params by adding `userId` condition. This prevents attacks by providing a query with a different `userId`.

        searchParams =
            q: 'userId:' + user.id + ' AND ' + query + ''
            include_docs: true

Include bookmark only if its truthy (otherwise Cloudant throws a tantrum).

        if bookmark
            searchParams.bookmark = bookmark

Perform the search and extract the included docs from the results.

        return app.couch.search USER_TEXT_SEARCH_DOC, INDEX, searchParams, (err, result) ->
            return callback err if err

            docs = _.map result.rows, (row) -> row.doc

            callback null, docs, result.bookmark

    exports.searchUserText = searchUserText
